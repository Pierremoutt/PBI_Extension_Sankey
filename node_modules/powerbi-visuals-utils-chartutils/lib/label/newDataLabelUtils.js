/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
import { interrupt } from "d3-transition";
import { pixelConverter } from "powerbi-visuals-utils-typeutils";
import { CssConstants } from "powerbi-visuals-utils-svgutils";
import { LabelOrientation, } from "./labelLayout";
export const DefaultLabelFontSizeInPt = 9;
export const startingLabelOffset = 8;
export const maxLabelOffset = 8;
export const horizontalLabelBackgroundPadding = 4;
export const verticalLabelBackgroundPadding = 2;
const labelsClass = CssConstants.createClassAndSelector("label");
function getLabelX(label) {
    const isVertical = label.labelOrientation === LabelOrientation.Vertical;
    const orientationOffset = isVertical ? label.boundingBox.width : (label.boundingBox.width / 2);
    const backgroundOffset = label.hasBackground && isVertical ? horizontalLabelBackgroundPadding : 0;
    return label.boundingBox.left + orientationOffset - backgroundOffset;
}
function getLabelY(label) {
    const isVertical = label.labelOrientation === LabelOrientation.Vertical;
    const orientationOffset = isVertical ? (label.boundingBox.height / 2) : label.boundingBox.height;
    const backgroundOffset = label.hasBackground && !isVertical ? verticalLabelBackgroundPadding : 0;
    return label.boundingBox.top + orientationOffset - backgroundOffset;
}
function labelKeyFunction(label, index) {
    if (label.key) {
        return label.key;
    }
    return index;
}
export function drawDefaultLabels(context, dataLabels, numeric = false, hasTooltip = false) {
    const labels = context
        .selectAll(labelsClass.selectorName)
        .data(dataLabels, labelKeyFunction);
    labels
        .exit()
        .remove();
    const dy = numeric
        ? undefined
        : "-0.15em";
    const mergedLabels = labels.enter()
        .append("text")
        .classed(labelsClass.className, true)
        .merge(labels);
    interrupt(mergedLabels.node());
    mergedLabels
        .text((label) => label.text)
        .attr("transform", (d) => {
        const translate = "translate(" + getLabelX(d) + "," + getLabelY(d) + ")";
        return (d.labelOrientation === LabelOrientation.Vertical) ? (translate + "rotate(-90)") : translate;
    })
        .attr("dy", dy)
        .style("fill", (d) => d.fill)
        .style("font-size", (d) => pixelConverter.fromPoint(d.fontSize || DefaultLabelFontSizeInPt))
        .style("font-family", (d) => d.fontFamily ? d.fontFamily : undefined)
        .style("text-anchor", (d) => d.textAnchor);
    if (hasTooltip) {
        labels.append("title").text((d) => d.tooltip);
        labels.style("pointer-events", "all");
    }
    return mergedLabels;
}
export const dataLabelLayoutStartingOffset = 2;
export const dataLabelLayoutOffsetIterationDelta = 6;
export const dataLabelLayoutMaximumOffset = dataLabelLayoutStartingOffset + (2 * dataLabelLayoutOffsetIterationDelta);
export function getDataLabelLayoutOptions(chartType) {
    switch (chartType) {
        case 10 /* CartesianChartType.Scatter */:
            return {
                maximumOffset: dataLabelLayoutMaximumOffset,
                startingOffset: dataLabelLayoutStartingOffset,
                offsetIterationDelta: dataLabelLayoutOffsetIterationDelta,
                allowLeaderLines: true,
                attemptToMoveLabelsIntoViewport: true,
            };
        default:
            return {
                maximumOffset: maxLabelOffset,
                startingOffset: startingLabelOffset,
                attemptToMoveLabelsIntoViewport: true,
            };
    }
}
export function getNumberOfLabelsToRender(viewportWidth, labelDensity, minimumLabelsToRender, estimatedLabelWidth) {
    if (labelDensity == null || labelDensity === 0) {
        return minimumLabelsToRender;
    }
    const parsedAndNormalizedDensity = labelDensity / 100;
    const maxNumberForViewport = Math.ceil(viewportWidth / estimatedLabelWidth);
    if (parsedAndNormalizedDensity === 1) {
        return maxNumberForViewport;
    }
    return minimumLabelsToRender + Math.floor(parsedAndNormalizedDensity * (maxNumberForViewport - minimumLabelsToRender));
}
//# sourceMappingURL=newDataLabelUtils.js.map